#Number puzzle

from collections import deque
goal = '123456780'
moves ={
    0: [1,3],
    1: [0,2,4],
    2: [1,5],
    3: [0,4,6],
    4: [1,3,5,7],
    5: [2,4,8],
    6: [3,7],
    7: [4,6,8],
    8: [5,7]
}
def bfs(start):
    visited = set()
    queue = deque([(start,[])])


    while queue:
        state, path = queue.popleft()
        if state == goal:
            return path + [state]
        if state in visited:
            continue
        visited.add(state)

        zero = state.index('0')
        for move in moves[zero]:
            new_state = list(state)
            new_state[zero], new_state[move] = new_state[move], new_state[zero]
            queue.append(('' . join (new_state), path+[state]))
    return None
start = '123405678'
solution = bfs(start)
if solution:
    print("steps to solve:")
    for s in solution:
        print(s [0:3])
        print(s [3:6])
        print(s [6:9])
        print("_______")
else:
    print("No solution found.")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

#Missionaries and Cannibals

from collections import deque

def valid(m_left, c_left, m_right, c_right):
    if m_left < 0 or c_left < 0 or m_right < 0 or c_right < 0:
        return False
    if m_left > 0 and c_left > m_left:
        return False
    if m_right > 0 and c_right > m_right:
        return False
    return True

def solve():
    start = (3, 3, 1)
    goal = (0, 0, 0)
    moves = [(2,0), (1,0), (0,1), (0,2), (1,1)]
    queue = deque([(start, [start])])
    visited = set()

    while queue:
        (m, c, boat), path = queue.popleft()
        if (m, c, boat) in visited:
            continue
        visited.add((m, c, boat))

        if (m, c, boat) == goal:
            return path

        for mm, cc in moves:
            if boat == 1:
                new_m = m - mm
                new_c = c - cc
                new_boat = 0
            else:
                new_m = m + mm
                new_c = c + cc
                new_boat = 1

            new_mr = 3 - new_m
            new_cr = 3 - new_c

            if valid(new_m, new_c, new_mr, new_cr):
                queue.append(((new_m, new_c, new_boat), path + [(new_m, new_c, new_boat)]))

    return None

result = solve()

if result:
    for i, (m, c, boat) in enumerate(result):
        side = "Left" if boat == 1 else "Right"
        print(f"Step {i}: M_left={m}, C_left={c}, Boat on {side}")
else:
    print("No solution found.")
